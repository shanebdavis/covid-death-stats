import &StandardImport, &Lib


formatNumber = (p) ->
  if isInfinite p
    :Infinity
  else
    switch
    when p >= 99999999 then "#{Math.round(p / 1000000)}m"
    when p >= 999999 then "#{(p / 1000000).toFixed 1}m"
    when p >= 99999 then "#{Math.round(p / 1000)}k"
    when p >= 9999 then "#{(p / 1000).toFixed 1}k"
    when p >= 999 then commaize Math.round p
    when p >= 100 then Math.round p
    when float32Eq (p | 0), p then p | 0
    when p >= 10 then p.toFixed 1
    else p.toFixed 2

formatProbability = (p) ->
  if p < .001001
    "1:#{formatNumber 1/p}"
  else
    100 * p
    .toFixed
      switch
      when p < .010001 then 3
      when p < .100001 then 2
      else 1
    + :%

c1 = rgbColor #e62322
c2 = rgbColor #ffb270
c3 = rgbColor #ffe96b

barColors =
  grey:
    grey = rgbColor #c
    grey.blend :black, 1 - .85
    grey.blend :black, 1 - .7
    grey.blend :black, 1 - .55
    grey.blend :black, 1 - .40

  color:
    []
      c1
      c1.blend :black, 1 - .85
      c1.blend :black, 1 - .7
      c1.blend :black, 1 - .55
      c1.blend :black, 1 - .40

oneColor = #aca8a8

class Bar extends ViewStateComponent

  @propFields :value :unit :label :maxValue :probabilityMode :colorPalette

  @stateFields
    mouseIn: null

  setMouseIn: ({target, location}) ->
    @mouseIn = point
      if location.x > target.currentSize.x / 2 then 1 else 0
      bound 0, location.y / target.currentSize.y, 1

  render: ->
    @ extract value
    if isInfinite value
      value = @maxValue

    colorPalette = barColors[@colorPalette] || barColors.grey

    bars = [] 1 # .1 .7 .5 .24 .8
    barWidth = 1 / bars.length
    barTotal = reduce a, b from bars inject 0 with a + b
    barMax = reduce a, b from bars inject 0 with max a, b

    layout = :stacked
    barSum = 0

    Element
      key: @label
      size:
        ww: 1
        hh: min 1, scale = value / @maxValue
      draw:
        array bar, i in bars
          rectangle:
            if layout == :stacked
              bar /= barTotal
              barSum += bar
              barPos = barSum
              (ps) -> rect 0, (1 - barPos) * ps.y, ps.x, bar * ps.y
            else
              bar /= barMax
              (ps) -> rect
                ps.x * i * barWidth
                (1 - bar) * ps.y
                ps.x * barWidth
                bar * ps.y

          fill: colorPalette[i % colorPalette.length]

      on:
        mouseIn: @setMouseIn

        mouseOut: ({target, location}) ->
          @setMouseIn {target, location}
          timeout 5 -> @clearMouseIn()

      animators:
        draw: {}
        size: toFrom: w: 0 hh: scale
        opacity: toFrom: 0

      Element
        :clip
        if @mouseIn?
          Element
            location: ps: @mouseIn
            axis: .5
            size: ({x, y}) -> point 1.41 * 2 * max x, y
            animators: size:
              d: 1
              toFrom: 0
            draw:
              :circle
              #ca00ca

      TextElement
        TextStyles.tinyBoldText
        :childrenSize
        axis: :bottomCenter
        location: h: -@gridSize / 2, xw: .5
        color: TextPalette.black.secondary
        text:
          if @value
            switch @probabilityMode
            when :relative :count then formatNumber @value
            when :probability then formatProbability @value
            else
              if isInfinite @value
                :infinity
              else
                @value + @unit
          else '' + @value

      TextElement
        TextStyles.tinyBoldText
        :childrenSize
        :textCenterCenter
        axis: :topCenter
        location: yh: 1 y: @gridSize * 2 xw: .5
        color: TextPalette.black.secondary
        text: @label
