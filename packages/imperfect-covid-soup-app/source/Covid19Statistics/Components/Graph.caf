import &StandardImport, &Widgets, &PagePart, &Partials, &Lib

isPublicValue = (b) -> b? && (b == 0 || b > 9)
minPrivValue = 1
maxPrivValue = 9

{showFullDetails} = getEnv()

fullDetails = (b) ->
  if b? then b else (maxPrivValue / minPrivValue) /2

valuesSum = (list, canShowAnyValue) ->
  reduce a, b from list inject [0 0] with
    if showFullDetails
      []
        a[0] + if b? then b else minPrivValue
        a[1] + if b? then b else maxPrivValue

    else if canShowAnyValue
      []
        v = a[0] + b
        v

    else
      []
        a[0] + if isPublicValue b then b else minPrivValue
        a[1] + if isPublicValue b then b else maxPrivValue

valuesMax = (list, canShowAnyValue) ->
  reduce a, b from list inject [0 0]
    if showFullDetails
      []
        max a[0], if b? then b else minPrivValue
        max a[1], if b? then b else maxPrivValue

    else if canShowAnyValue
      []
        v = max a[0], b
        v
    else
      []
        max a[0], if isPublicValue b then b else minPrivValue
        max a[1], if isPublicValue b then b else maxPrivValue

class Graph extends ViewStateComponent

  @subscriptions
    :covidData
    :graphState

  @stateFields
    selectedData: null
    showOptionsFor: null
    exampleData: null
    previousMaxValue: null

  @propFields :animationOn

  applyScale = (scale, obj) ->
    if scale? && scale != 1
      object v, k in obj with v * scale
    else obj

  createSelectedDataEntry = (covidDataRecord, region, age, intentData, mechanismData, scale) ->
    merge
      covidDataRecord
      nonCovid19Deaths: covidDataRecord.totalDeaths - covidDataRecord.covid19Deaths
      applyScale scale, {totalDeaths: totalDeaths2019, accident: accidentDeaths2019, homicide: homicides2019, suicide: suicides2019} = intentData?[region]?[age] ? {}
      applyScale scale, {drowning: drownings2019, motorVehicle: carAccidents2019, disease: diseaseDeaths2019, firearm: firearmDeaths2019, poisoning: poisonings2019, suffocation: suffocationDeaths2019, fall: deathFromFalls2019} = mechanismData?[region]?[age] ? {}

  preprocessState: (newState) ->
    newState.covidData extract? covidData, intentData, mechanismData, times, ages
    newState.graphState extract? region, time, age, graphType
    [aRegion] = region
    [aTime] = time
    [anAge] = age

    [axis] = graphType

    axisKeys = if axis == :time
      switch aTime
      when "All Time"
        array v from times when !/^(All.*|202\d|last.*)$/i.test v
      when "last12Months"
        a = array v from times when !/^(All.*|202\d|last.*)$/i.test v
        a.slice a.length - 13, a.length - 1
      else time
    else
      if anAge == "All Ages"
        array v from ages when !/^All/.test v
      else age

    merge
      newState
      exampleData: createSelectedDataEntry
        covidData.UnitedStates["All Time"]["All Ages"]
        :UnitedStates
        "All Ages"
        intentData
        mechanismData

      selectedData:
        unless covidData
          {}
        else
          if axis == :time
            object aTime from axisKeys
              if region.length > 1
                array aRegion in region
                  createSelectedDataEntry
                    covidData[aRegion][aTime][anAge]
                    aRegion
                    anAge
                    intentData
                    mechanismData
                    1/12

              else
                array anAge in age
                  createSelectedDataEntry
                    covidData[aRegion][aTime][anAge]
                    aRegion
                    anAge
                    intentData
                    mechanismData
                    1/12

          else
            object anAge from axisKeys
              if region.length > 1
                array aRegion in region
                  createSelectedDataEntry
                    covidData[aRegion][aTime][anAge]
                    aRegion
                    anAge
                    intentData
                    mechanismData

              else
                array aTime in time
                  createSelectedDataEntry
                    covidData[aRegion][aTime][anAge]
                    aRegion
                    anAge
                    intentData
                    mechanismData

  valueCalc: (row, numerator, denominator) ->
    n = if numerator == "1" then 1 else row[numerator]
    d = if denominator == "1" then 1 else row[denominator]
    if n? && d?
      n / d
    else null

  getDataSelectedData: (rows, label) ->
    @graphState extract layout, numerator, denominator
    # log [label]: {} rows, numerator
    [firstRow] = rows

    values =
      if numerator.length > 1
        array n in numerator with @valueCalc firstRow, n, denominator[0]
      else if denominator.length > 1
        array d in denominator with @valueCalc firstRow, numerator[0], d
      else
        array row in rows with @valueCalc row, numerator[0], denominator[0]

    [lowValue, highValue] =
      if layout[0] == :stacked
        valuesSum values, @haveDenominator
      else
        valuesMax values, @haveDenominator

    {}
      label:
        if m = label.match /(^\d+)-(\d+)$/
          [_, year, month] = m
          "#{months[month|0]}\n#{year}"
        else
          label
          .replace /Under /g 'Under\n'
          .replace /[ ]years/g '\nyears'

      values
      value: (lowValue + highValue) / 2
      valueLabel: if lowValue == highValue then highValue else "#{lowValue} - #{highValue}"

  @getter
    haveDenominator: ->
      @graphState extract denominator
      !(denominator.length == 1 && denominator[0] == "1")

    data: ->
      @graphState extract layout, numerator, denominator
      array rows, label in @selectedData
        @getDataSelectedData rows, label

    adjacent: -> @graphState.layout[0] == :adjacent

    calculatedMaxValue: ->
      maxNonInfiniteValue
        array {value, values, label} from @data when !/All|Jan\n2020|Feb\n2020/.test label
          if @adjacent
            maxNonInfiniteValue values
          else
            sumNonInfiniteValues values

    maxValue: ->

      unless isInfinite maxValue = @calculatedMaxValue
        if @previousMaxValue == bound maxValue, @previousMaxValue, 4 * maxValue
          if maxValue != @previousMaxValue
            log usePreviousMaxValue: formatNumber @previousMaxValue
          @previousMaxValue
        else
          log updateMaxValue: formatNumber maxValue
          @previousMaxValue = maxValue

      else 1

  invertEquation: ->
    models.graphState.setState
      numerator: @graphState.denominator
      denominator: @graphState.numerator

  render: ->
    @ extract maxValue
    preset = &Presets[@graphState.preset]
    custom = find v, k in preset.graphState when neq v, @graphState[k]

    @graphState extract layout, numerator, denominator
    hasDenominator = denominator.length > 1 || denominator[0] != "1"
    hasNumerator = numerator.length > 1 || numerator[0] != "1"
    Element
      :column
      childrenMargins: @gridSize * 4

      animators:
        if @animationOn
          location:
            duration: 2
            f: :easeInQuad
            from: xw: -1 y: 0
        else {}

      Element
        Element
          # :row
          animators: opacity: toFrom: 0
          padding: h: -@gridSize / 2
          array row, i in @data
            Bar row, {}
              location: xw: i / @data.length
              size: ww: 1 / @data.length
              numBars: @data.length
              key: row.label
              layout: layout[0]
              maxValue
              unit: !custom && preset.graphState.unit
              colorPalette: if hasDenominator && hasNumerator then :color else :grey
              probabilityMode:
                if row.value >= 1
                  if hasDenominator then :relative
                  else :count
                else :probability

        Element
          location:
            yh: 1 y: -@gridSize * 3
          key: :line
          axis: y: .5
          size:
            h: @gridSize / 2
            ww: 1
          draw: TextPalette.black.primary

      PageBottom {} preset, custom
