import &StandardImport

max = (a, b) ->
  if isInfinite(a) || isInfinite(b)
    Infinity
  else if a > b then a else b

add = (a, b) ->
  if isInfinite(a) || isInfinite(b)
    Infinity
  else a + b

formatNumber = (p, unit) ->
  if isInfinite p
    if unit then "Infinite #{unit}"
    else :Infinity
  else
    a =
      switch
      when p >= 99999999 then "#{Math.round(p / 1000000)}m"
      when p >= 999999 then "#{(p / 1000000).toFixed 1}m"
      when p >= 99999 then "#{Math.round(p / 1000)}k"
      when p >= 9999 then "#{(p / 1000).toFixed 1}k"
      when p >= 999 then commaize Math.round p
      when p >= 100 then Math.round p
      when float32Eq (p | 0), p then p | 0
      when p >= 10 then p.toFixed 1
      else p.toFixed 2
    if unit then "#{a} #{unit}"
    else a

formatProbability = (p) ->
  if p < .001001
    "1:#{formatNumber 1/p}"
  else
    100 * p
    .toFixed
      switch
      when p < .010001 then 3
      when p < .100001 then 2
      else 1
    + :%

c1 = rgbColor #e62322
c2 = rgbColor #ffb270
c3 = rgbColor #ffe96b

barColors =
  grey:
    grey = rgbColor #c
    grey.blend :black, 1 - .85
    grey.blend :black, 1 - .7
    grey.blend :black, 1 - .55
    grey.blend :black, 1 - .40

  color:
    []
      c1
      c1.blend :black, 1 - .85
      c1.blend :black, 1 - .7
      c1.blend :black, 1 - .55
      c1.blend :black, 1 - .40

oneColor = #aca8a8

class Bar extends ViewStateComponent

  @propFields :numBars :value :values :valueLabel :unit :label :maxValue :probabilityMode :colorPalette :layout

  @stateFields
    mouseIn: null

  setMouseIn: ({target, location}) ->
    @mouseIn = point
      if location.x > target.currentSize.x / 2 then 1 else 0
      bound 0, location.y / target.currentSize.y, 1

  render: ->
    @ extract value, values, layout, label, maxValue

    labelValue = value

    bars = array v in values
      v / value

    if isInfinite value
      value = maxValue

    colorPalette = barColors[@colorPalette] || barColors.grey

    barWidth = 1 / bars.length
    barTotal = reduce a, b from bars inject 0 with add a, b
    barMax = reduce a, b from bars inject 0 with max a, b

    barSum = 0

    Element
      size:
        ww: 1
        hh: min 1, scale = value / maxValue

      padding: h: @gridSize / 2
      on:
        mouseIn: @setMouseIn

        mouseOut: ({target, location}) ->
          @setMouseIn {target, location}
          timeout 5 -> @clearMouseIn()

      animators:
        size: toFrom: w: 0 hh: scale
        opacity: toFrom: 0

      Element
        animators:
          draw: duration: 1
        draw:
          :clip

          array bar, i in bars
            rectangle:
              if layout == :stacked
                bar = if barTotal > 0
                  if isInfinite bar
                    maxValue
                  else
                    bar / barTotal

                else 0

                barSum += bar
                barPos = barSum
                (ps) -> rect 0, (1 - barPos) * ps.y, ps.x, bar * ps.y
              else
                bar = if barMax > 0
                  if isInfinite bar
                    maxValue
                  else
                    bar / barMax

                else 0
                (ps) -> rect
                  ps.x * i * barWidth
                  (1 - bar) * ps.y
                  ps.x * barWidth
                  bar * ps.y

            fill: colorPalette[i % colorPalette.length]

      Element
        :clip
        if @mouseIn?
          Element
            location: ps: @mouseIn
            axis: .5
            size: ({x, y}) -> point 1.41 * 2 * max x, y
            animators: size:
              d: 1
              toFrom: 0
            draw:
              :circle
              #ca00ca

      TextElement
        TextStyles.mediumBoldText
        fontSize: bound
          TextStyles.tinyBoldText.fontSize
          TextStyles.mediumBoldText.fontSize * 9 / @numBars
          TextStyles.xLargeBoldText.fontSize

        :childrenSize
        animators: :fontSize
        axis: :bottomCenter
        location: h: -@gridSize / 2, xw: .5
        color: TextPalette.black.primary
        text:
          if @valueLabel is String
            @valueLabel
          else if labelValue
            switch @probabilityMode
            when :relative :count then formatNumber labelValue, @unit
            when :probability then formatProbability labelValue, @unit
            else
              if isInfinite labelValue
                :infinity
              else
                labelValue + @unit
          else '' + labelValue

      TextElement
        TextStyles.tinyBoldText
        :childrenSize
        :textCenterCenter
        axis: :topCenter
        location: yh: 1 y: @gridSize * 2 xw: .5
        color: TextPalette.black.secondary
        text: label
